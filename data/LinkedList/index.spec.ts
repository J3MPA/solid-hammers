import { LinkedList } from '.'

describe('LinkedList', () => {
  it('should create a new LinkedList instance given correct arguments', () => {
    const LL1 = new LinkedList()
    expect(LL1.size).toBe(0)
    expect(LL1.head).toBe(null)
    expect(LL1.middle).toBe(null)
    expect(LL1.tail).toBe(null)
    const ref = {}
    const LL2 = new LinkedList(ref)
    expect(LL2.size).toBe(1)
    expect(LL2.head?.value).toBe(ref)
    expect(LL2.middle?.value).toBe(ref)
    expect(LL2.tail?.value).toBe(ref)
  })
  describe('push', () => {
    describe('Happy path', () => {
      it('should push new link on an empty LinkedList', () => {
        const sym = Symbol(1)
        const LL = new LinkedList<typeof sym>()
        expect(LL.size).toBe(0)
        expect(LL.head).toBe(null)
        expect(LL.middle).toBe(null)
        expect(LL.tail).toBe(null)
        LL.push(sym)
        expect(LL.size).toBe(1)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym)
        expect(LL.middle?.value).toBe(sym)
        expect(LL.tail?.value).toBe(sym)
        expect(LL.tail?.next).toBe(null)
      })
      it('should push multiple links on an empty LinkedList', () => {
        const sym1 = Symbol(1)
        const LL = new LinkedList<symbol>(sym1)

        const sym2 = Symbol(2)
        LL.push(sym2)
        expect(LL.size).toBe(2)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym1)
        expect(LL.head?.next?.value).toBe(sym2)
        expect(LL.middle?.value).toBe(sym1)
        expect(LL.tail?.value).toBe(sym2)
        expect(LL.tail?.prev?.value).toBe(sym1)
        expect(LL.tail?.next).toBe(null)

        const sym3 = Symbol(3)
        LL.push(sym3)
        expect(LL.size).toBe(3)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym1)
        expect(LL.head?.next?.value).toBe(sym2)
        expect(LL.middle?.value).toBe(sym2)
        expect(LL.tail?.value).toBe(sym3)
        expect(LL.tail?.prev?.value).toBe(sym2)
        expect(LL.tail?.next).toBe(null)

        const sym4 = Symbol(4)
        LL.push(sym4)
        expect(LL.size).toBe(4)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym1)
        expect(LL.head?.next?.value).toBe(sym2)
        expect(LL.middle?.value).toBe(sym2)
        expect(LL.tail?.value).toBe(sym4)
        expect(LL.tail?.prev?.value).toBe(sym3)
        expect(LL.tail?.next).toBe(null)
      })
    })
  })
  describe('pop', () => {
    describe('Happy path', () => {
      it('should pop link off a LinkedList', () => {
        const sym1 = Symbol(1)
        const LL = new LinkedList<symbol>(sym1)

        const sym2 = Symbol(2)
        LL.push(sym2)
        const sym3 = Symbol(3)
        LL.push(sym3)
        const sym4 = Symbol(4)
        LL.push(sym4)
        LL.pop()
        expect(LL.size).toBe(3)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym1)
        expect(LL.head?.next?.value).toBe(sym2)
        expect(LL.middle?.value).toBe(sym2)
        expect(LL.tail?.value).toBe(sym3)
        expect(LL.tail?.prev?.value).toBe(sym2)
        expect(LL.tail?.next).toBe(null)
      })
      it('should pop multiple links off a LinkedList', () => {
        const sym1 = Symbol(1)
        const LL = new LinkedList<symbol>(sym1)

        const sym2 = Symbol(2)
        LL.push(sym2)
        const sym3 = Symbol(3)
        LL.push(sym3)
        const sym4 = Symbol(4)
        LL.push(sym4)
        const sym5 = Symbol(5)
        LL.push(sym5)
        const sym6 = Symbol(6)
        LL.push(sym6)
        LL.pop()
        LL.pop()
        LL.pop()
        expect(LL.size).toBe(3)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym1)
        expect(LL.head?.next?.value).toBe(sym2)
        expect(LL.middle?.value).toBe(sym2)
        expect(LL.tail?.value).toBe(sym3)
        expect(LL.tail?.prev?.value).toBe(sym2)
        expect(LL.tail?.next).toBe(null)

        LL.pop()
        expect(LL.size).toBe(2)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym1)
        expect(LL.head?.next?.value).toBe(sym2)
        expect(LL.middle?.value).toBe(sym1)
        expect(LL.tail?.value).toBe(sym2)
        expect(LL.tail?.prev?.value).toBe(sym1)
        expect(LL.tail?.next).toBe(null)

        LL.pop()
        expect(LL.size).toBe(1)
        expect(LL.head?.prev).toBe(null)
        expect(LL.head?.value).toBe(sym1)
        expect(LL.middle?.value).toBe(sym1)
        expect(LL.tail?.value).toBe(sym1)
        expect(LL.tail?.next).toBe(null)

        LL.pop()
        expect(LL.size).toBe(0)
        expect(LL.head).toBe(null)
        expect(LL.middle).toBe(null)
        expect(LL.tail).toBe(null)
      })
    })
  })
})
